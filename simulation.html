<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Epimetabolic Simulation — The Dionysus Program</title>
  <meta name="description" content="Interactive simulation of the Epimetabolic Equation from The Dionysus Program.">
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <main>
    <header class="page-header">
      <h1>The Dionysus Program</h1>
      <p class="page-subtitle">An Epimetabolic Simulation</p>
      <p class="page-download">
        <a href="index.html">← Back to Essay</a>
      </p>
    </header>

    <div id="epimetabolic-simulation-root" class="simulation-container"></div>

    <footer class="page-footer">
      <p class="page-rights">© 2025 Sean Devine. All rights reserved.</p>
    </footer>
  </main>

<script type="importmap">
{
  "imports": {
    "react": "https://esm.sh/react@18.2.0",
    "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
    "recharts": "https://esm.sh/recharts@2.12.7?external=react"
  }
}
</script>

<script type="module">
import React, { useState, useEffect, createElement as h } from 'react';
import { createRoot } from 'react-dom/client';
import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, ResponsiveContainer, Legend } from 'recharts';

const RefreshIcon = () => h('svg', { width: 12, height: 12, viewBox: '0 0 24 24', fill: 'none', stroke: 'currentColor', strokeWidth: 2, strokeLinecap: 'round', strokeLinejoin: 'round' },
  h('path', { d: 'M21 12a9 9 0 0 0-9-9 9.75 9.75 0 0 0-6.74 2.74L3 8' }),
  h('path', { d: 'M3 3v5h5' }),
  h('path', { d: 'M3 12a9 9 0 0 0 9 9 9.75 9.75 0 0 0 6.74-2.74L21 16' }),
  h('path', { d: 'M16 16h5v5' })
);

const InfoIcon = () => h('svg', { width: 18, height: 18, viewBox: '0 0 24 24', fill: 'none', stroke: 'currentColor', strokeWidth: 2, strokeLinecap: 'round', strokeLinejoin: 'round', className: 'sim-info-icon' },
  h('circle', { cx: 12, cy: 12, r: 10 }),
  h('path', { d: 'M12 16v-4' }),
  h('path', { d: 'M12 8h.01' })
);

const SettingsIcon = () => h('svg', { width: 12, height: 12, viewBox: '0 0 24 24', fill: 'none', stroke: 'currentColor', strokeWidth: 2, strokeLinecap: 'round', strokeLinejoin: 'round' },
  h('path', { d: 'M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1-1-1.74v-.5a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z' }),
  h('circle', { cx: 12, cy: 12, r: 3 })
);

// Archetype presets with representative parameters
const ARCHETYPES = {
  // Thriving
  DIONYSIAN_IDEAL: {
    name: 'The Dionysian Ideal',
    category: 'Thriving',
    description: 'High melt converted to growth, trust grows alongside reach.',
    params: { mu_env: 12, mu_choice: 5, L: 18, R0: 150, rho: 0.5, beta: 3.5, tau: 0.5 }
  },
  HIGH_PERFORMER: {
    name: 'The High Performer',
    category: 'Thriving',
    description: 'Strong growth, trust maintained. Sustainable and productive.',
    params: { mu_env: 12, mu_choice: 5, L: 18, R0: 150, rho: 0.3, beta: 2.0, tau: 1.5 }
  },
  VIRTUOUS_CYCLE: {
    name: 'The Virtuous Cycle',
    category: 'Thriving',
    description: 'Trust and capability reinforce each other upward.',
    params: { mu_env: 12, mu_choice: 8, L: 18, R0: 20, rho: 0.5, beta: 3.5, tau: 0.5 }
  },
  MODERATE_GROWTH: {
    name: 'Moderate Growth',
    category: 'Thriving',
    description: 'Healthy but unspectacular. The organizational B+.',
    params: { mu_env: 12, mu_choice: 8, L: 18, R0: 100, rho: 0.5, beta: 1.0, tau: 0.5 }
  },
  // Edge Cases
  FRAGILE_SURVIVOR: {
    name: 'The Fragile Survivor',
    category: 'Edge Cases',
    description: 'Survival depends on luck. No margin for error.',
    params: { mu_env: 12, mu_choice: 0, L: 18, R0: 150, rho: 0.15, beta: 3.5, tau: 1.5 }
  },
  GAMBLER: {
    name: 'The Gambler',
    category: 'Edge Cases',
    description: 'Bet big on disruption. Volatile outcomes.',
    params: { mu_env: 3, mu_choice: 5, L: 12, R0: 150, rho: 0.15, beta: 1.0, tau: 1.5 }
  },
  // Pyrrhic
  PYRRHIC_LEADER: {
    name: 'The Pyrrhic Leader',
    category: 'Pyrrhic',
    description: 'Ahead competitively but burning through the team.',
    params: { mu_env: 12, mu_choice: 5, L: 18, R0: 100, rho: 0.5, beta: 0.2, tau: 2.5 }
  },
  CHURN_MACHINE: {
    name: 'The Churn Machine',
    category: 'Pyrrhic',
    description: 'High rotation prevents decay but also prevents memory.',
    params: { mu_env: 12, mu_choice: 5, L: 18, R0: 100, rho: 0.5, beta: 0.2, tau: 1.5 }
  },
  // Decline
  SLOW_DECLINE: {
    name: 'The Slow Decline',
    category: 'Decline',
    description: 'Losing ground slowly. Needs intervention to reverse.',
    params: { mu_env: 1, mu_choice: 0, L: 8, R0: 20, rho: 0.05, beta: 0.5, tau: 1.5 }
  },
  // Competitive Collapse
  SITTING_DUCK: {
    name: 'The Sitting Duck',
    category: 'Competitive Collapse',
    description: 'Refused to engage with disruption. Industry moved on.',
    params: { mu_env: 5, mu_choice: 0, L: 5, R0: 100, rho: 0.15, beta: 0.2, tau: 2.5 }
  },
  OUTPACED: {
    name: 'The Outpaced',
    category: 'Competitive Collapse',
    description: 'Tried to keep up but couldn\'t. Good team, wrong decade.',
    params: { mu_env: 5, mu_choice: 2, L: 5, R0: 100, rho: 0.3, beta: 2.0, tau: 0.5 }
  },
  // Internal Collapse
  MANAGEMENT_THEATER: {
    name: 'Management Theater',
    category: 'Internal Collapse',
    description: 'Rituals exceed trust. Hollow performances destroy.',
    params: { mu_env: 5, mu_choice: 8, L: 12, R0: 10, rho: 0.05, beta: 0.2, tau: 2.5 }
  },
  OVERWHELMED: {
    name: 'The Overwhelmed',
    category: 'Internal Collapse',
    description: 'Melt exceeds capacity. Even good intent can\'t keep up.',
    params: { mu_env: 1, mu_choice: 8, L: 2, R0: 10, rho: 0, beta: 0.2, tau: 1.5 }
  },
  OLIGARCHIC_DECAY: {
    name: 'Oligarchic Decay',
    category: 'Internal Collapse',
    description: 'No rotation, stewardship calcifies. Weber wins.',
    params: { mu_env: 1, mu_choice: 5, L: 18, R0: 10, rho: 0.02, beta: 0.2, tau: 0.5 }
  },
  DEATH_SPIRAL: {
    name: 'The Death Spiral',
    category: 'Internal Collapse',
    description: 'Decay exceeds growth. Trust evaporates.',
    params: { mu_env: 1, mu_choice: 8, L: 8, R0: 10, rho: 0.5, beta: 0.2, tau: 2.5 }
  }
};

// Group archetypes by category for the selector
const ARCHETYPE_CATEGORIES = [
  { name: 'Thriving', keys: ['DIONYSIAN_IDEAL', 'HIGH_PERFORMER', 'VIRTUOUS_CYCLE', 'MODERATE_GROWTH'] },
  { name: 'Edge Cases', keys: ['FRAGILE_SURVIVOR', 'GAMBLER'] },
  { name: 'Pyrrhic', keys: ['PYRRHIC_LEADER', 'CHURN_MACHINE'] },
  { name: 'Decline', keys: ['SLOW_DECLINE'] },
  { name: 'Competitive Collapse', keys: ['SITTING_DUCK', 'OUTPACED'] },
  { name: 'Internal Collapse', keys: ['MANAGEMENT_THEATER', 'OVERWHELMED', 'OLIGARCHIC_DECAY', 'DEATH_SPIRAL'] }
];

function SliderControl({ label, symbol, value, min, max, step, desc, onChange }) {
  return h('div', { className: 'sim-slider-group' },
    h('div', { className: 'sim-slider-header' },
      h('label', { className: 'sim-slider-label' },
        h('span', { className: 'sim-symbol' }, symbol),
        ' ',
        label
      ),
      h('span', { className: 'sim-slider-value' }, value)
    ),
    h('p', { className: 'sim-slider-desc' }, desc),
    h('input', {
      type: 'range',
      min: min,
      max: max,
      step: step,
      value: value,
      onChange: function(e) { onChange(parseFloat(e.target.value)); },
      className: 'sim-slider'
    })
  );
}

// Parse archetype from URL query params
function getArchetypeFromURL() {
  const params = new URLSearchParams(window.location.search);
  const archetype = params.get('archetype');
  if (archetype && ARCHETYPES[archetype]) {
    return archetype;
  }
  return null;
}

// Update URL when archetype changes
function updateURL(archetypeKey) {
  const url = new URL(window.location);
  if (archetypeKey) {
    url.searchParams.set('archetype', archetypeKey);
  } else {
    url.searchParams.delete('archetype');
  }
  window.history.replaceState({}, '', url);
}

function EpimetabolicSimulation() {
  // Check URL for initial archetype
  const initialArchetype = getArchetypeFromURL();
  const initialParams = initialArchetype
    ? Object.assign({}, {
        mu_env: 3.0,
        mu_choice: 2.0,
        L: 8.0,
        rho: 0.1,
        beta: 1.0,
        tau: 1.5,
        R0: 100.0,
        alpha: 0.02,
        gamma: 0.10,
        delta: 0.05,
        kappa: 0.50,
        lambda: 0.20
      }, ARCHETYPES[initialArchetype].params)
    : {
        mu_env: 3.0,
        mu_choice: 2.0,
        L: 8.0,
        rho: 0.1,
        beta: 1.0,
        tau: 1.5,
        R0: 100.0,
        alpha: 0.02,
        gamma: 0.10,
        delta: 0.05,
        kappa: 0.50,
        lambda: 0.20
      };

  const [inputs, setInputs] = useState(initialParams);

  const [simulationData, setSimulationData] = useState([]);
  const [seed, setSeed] = useState(Date.now());
  const [collapseType, setCollapseType] = useState(null);
  const [selectedArchetype, setSelectedArchetype] = useState(initialArchetype);

  function selectArchetype(key) {
    if (key === '') {
      setSelectedArchetype(null);
      updateURL(null);
      return;
    }
    const archetype = ARCHETYPES[key];
    if (archetype) {
      setSelectedArchetype(key);
      updateURL(key);
      setInputs(function(prev) {
        return Object.assign({}, prev, archetype.params);
      });
      setSeed(Date.now());
    }
  }

  useEffect(function() {
    var data = [];
    var S = 10.0;
    var S_threshold = 10.0; // Competitive threshold starts at initial S
    var R = inputs.R0;
    var C = 1.0;
    var collapse = null;

    var randomVals = [];
    for (var i = 0; i < 100; i++) {
      var x = Math.sin(seed + i) * 10000;
      randomVals.push(x - Math.floor(x));
    }

    var mu = inputs.mu_env + inputs.mu_choice;

    for (var t = 0; t < 100; t++) {
      var Omega = Math.min(inputs.L * C, R);
      var Theater = Math.max(0, (inputs.L * C) - R);
      var Overflow = Math.max(0, mu - Omega);

      var G = Math.min(mu, Omega) * (1 + inputs.lambda * inputs.beta);
      var safeBeta = Math.max(0.1, inputs.beta);
      var D = (Math.pow(Overflow, 2) * inputs.tau) + ((inputs.kappa * Theater) / safeBeta);

      var deltaS = G - D;
      S = S + deltaS;

      // Competitive threshold rises with environmental melt
      S_threshold = S_threshold + inputs.mu_env;

      var R_prev = R;
      R = Math.max(0, R + (inputs.alpha * inputs.beta * G) - (inputs.gamma * D));

      var isReset = randomVals[t] < inputs.rho;
      var C_prev = C;

      if (isReset) {
        C = 1.0;
      } else {
        C = C * (1 - inputs.delta);
      }

      data.push({
        t: t,
        S: parseFloat(S.toFixed(2)),
        S_threshold: parseFloat(S_threshold.toFixed(2)),
        R: parseFloat(R.toFixed(2)),
        C: parseFloat(C_prev.toFixed(2))
      });

      // Check failure conditions
      if (collapse === null) {
        if (R <= 0) {
          collapse = 'internal';
        } else if (S < S_threshold) {
          collapse = 'competitive';
        }
      }

      if (R <= 0) break;
    }

    setSimulationData(data);
    setCollapseType(collapse);
  }, [inputs, seed]);

  function updateInput(key, value) {
    setInputs(function(prev) {
      var next = Object.assign({}, prev);
      next[key] = value;
      return next;
    });
  }

  var lastData = simulationData[simulationData.length - 1] || { S: 0, R: 0, S_threshold: 10 };
  var internalCollapse = simulationData.length < 100;
  var competitiveCollapse = collapseType === 'competitive';
  var anyCollapse = internalCollapse || competitiveCollapse;

  var collapseLabel = null;
  if (internalCollapse) {
    collapseLabel = 'Internal Collapse (Trust → 0)';
  } else if (competitiveCollapse) {
    collapseLabel = 'Competitive Collapse (S < S̄)';
  }

  return h('div', { className: 'sim-wrapper' },
    // Archetype selector
    h('div', { className: 'sim-archetype-selector' },
      h('label', { className: 'sim-archetype-label' }, 'Load Archetype:'),
      h('select', {
        className: 'sim-archetype-select',
        value: selectedArchetype || '',
        onChange: function(e) { selectArchetype(e.target.value); }
      },
        h('option', { value: '' }, '— Select an archetype —'),
        ARCHETYPE_CATEGORIES.map(function(cat) {
          return h('optgroup', { key: cat.name, label: cat.name },
            cat.keys.map(function(key) {
              return h('option', { key: key, value: key }, ARCHETYPES[key].name);
            })
          );
        })
      ),
      selectedArchetype && h('p', { className: 'sim-archetype-desc' },
        ARCHETYPES[selectedArchetype].description
      )
    ),
    // Chart at full width
    h('div', { className: 'sim-chart-container' },
      h('div', { className: 'sim-chart-header' },
        h('h4', { className: 'sim-chart-title' }, 'System Evolution ', h('span', { className: 'sim-chart-range' }, '(t=0 to 100)')),
        collapseLabel && h('span', { className: 'sim-death-spiral' }, collapseLabel)
      ),
      h('div', { className: 'sim-chart' },
        h(ResponsiveContainer, { width: '100%', height: '100%' },
          h(LineChart, { data: simulationData, margin: { top: 5, right: 30, left: 0, bottom: 5 } },
            h(CartesianGrid, { strokeDasharray: '3 3', stroke: '#e7e2da', vertical: false }),
            h(XAxis, { dataKey: 't', type: 'number', domain: [0, 100], stroke: '#9ca3af', tickLine: false, axisLine: { stroke: '#e5e7eb' }, tick: { fill: '#9ca3af', fontSize: 10 } }),
            h(YAxis, { yAxisId: 'left', stroke: '#4b5563', tick: { fill: '#6b7280', fontSize: 10 }, axisLine: false, tickLine: false }),
            h(YAxis, { yAxisId: 'right', orientation: 'right', domain: [0, 1], hide: true }),
            h(Tooltip, { contentStyle: { backgroundColor: '#faf8f4', borderColor: '#e7e2da', fontFamily: '"Iowan Old Style", Palatino, serif', fontSize: '14px', boxShadow: '0 4px 6px -1px rgba(0,0,0,0.1)', padding: '12px' }, itemStyle: { color: '#333' }, labelStyle: { color: '#9ca3af', marginBottom: '8px', fontSize: '12px', textTransform: 'uppercase', letterSpacing: '0.1em' } }),
            h(Legend, { verticalAlign: 'top', height: 36, iconType: 'plainline', wrapperStyle: { paddingBottom: '20px', fontSize: '12px', fontFamily: 'system-ui, sans-serif' } }),
            h(Line, { yAxisId: 'left', type: 'monotone', dataKey: 'S', name: 'Explanatory Reach (S)', stroke: '#41403b', strokeWidth: 2.5, dot: false, activeDot: { r: 5, fill: '#41403b', stroke: '#fff', strokeWidth: 2 }, isAnimationActive: true, animationDuration: 1000 }),
            h(Line, { yAxisId: 'left', type: 'monotone', dataKey: 'S_threshold', name: 'Competitive Threshold (S̄)', stroke: '#dc2626', strokeWidth: 1.5, strokeDasharray: '2 2', dot: false, activeDot: { r: 4, fill: '#dc2626', stroke: '#fff', strokeWidth: 2 }, isAnimationActive: true, animationDuration: 1000 }),
            h(Line, { yAxisId: 'left', type: 'monotone', dataKey: 'R', name: 'Ren (Trust)', stroke: '#b45309', strokeWidth: 2, strokeDasharray: '4 4', dot: false, activeDot: { r: 5, fill: '#b45309', stroke: '#fff', strokeWidth: 2 }, isAnimationActive: true, animationDuration: 1000 }),
            h(Line, { yAxisId: 'right', type: 'stepAfter', dataKey: 'C', name: 'Stewardship (C)', stroke: '#d4d4d4', strokeWidth: 1.5, dot: false, isAnimationActive: false })
          )
        )
      )
    ),
    // Metrics row
    h('div', { className: 'sim-metrics' },
      h('div', { className: 'sim-metric sim-metric-reach' },
        h('h5', { className: 'sim-metric-title' }, 'Final Reach (', h('em', null, 'S'), ')'),
        h('div', { className: 'sim-metric-value-row' },
          h('div', { className: 'sim-metric-value' }, lastData.S.toFixed(1)),
          h('div', { className: 'sim-metric-delta ' + (lastData.S > lastData.S_threshold ? 'positive' : 'negative') },
            'vs S̄: ', (lastData.S - lastData.S_threshold).toFixed(1)
          )
        ),
        h('div', { className: 'sim-metric-hint' }, 'Must stay above competitive threshold (S̄).')
      ),
      h('div', { className: 'sim-metric sim-metric-trust ' + (anyCollapse ? 'collapsed' : '') },
        h('h5', { className: 'sim-metric-title' }, 'Ren (Trust) (', h('em', null, 'R'), ')'),
        h('div', { className: 'sim-metric-value' }, lastData.R.toFixed(1)),
        h('div', { className: 'sim-metric-status ' + (anyCollapse ? 'danger' : 'ok') },
          anyCollapse ? (internalCollapse ? 'Internal collapse at t=' + simulationData.length : 'Outpaced by competition') : 'System Survives'
        )
      )
    ),
    // Two-column controls
    h('div', { className: 'sim-controls-grid' },
      h('div', { className: 'sim-controls-col' },
        h('h4', { className: 'sim-section-title' }, 'Environment & Choices'),
        h(SliderControl, { label: 'Environmental Melt', symbol: 'μᵉⁿᵛ', value: inputs.mu_env, min: 0, max: 15, step: 0.5, desc: 'Disruption the world imposes. Not a choice.', onChange: function(v) { updateInput('mu_env', v); } }),
        h(SliderControl, { label: 'Chosen Melt', symbol: 'μᶜʰᵒⁱᶜᵉ', value: inputs.mu_choice, min: 0, max: 10, step: 0.5, desc: 'Deliberate disruption (R&D, experiments).', onChange: function(v) { updateInput('mu_choice', v); } }),
        h(SliderControl, { label: 'Initial Ren (Trust)', symbol: 'R₀', value: inputs.R0, min: 10, max: 200, step: 10, desc: 'Starting social capital / trust.', onChange: function(v) { updateInput('R0', v); } }),
        h(SliderControl, { label: 'Li (Ritual)', symbol: 'L', value: inputs.L, min: 1, max: 20, step: 0.5, desc: 'Architectural capacity of the forms.', onChange: function(v) { updateInput('L', v); } }),
        h(SliderControl, { label: 'Rotation Rate', symbol: 'ρ', value: inputs.rho, min: 0, max: 1, step: 0.05, desc: 'Frequency of stewardship reset.', onChange: function(v) { updateInput('rho', v); } }),
        h(SliderControl, { label: 'Beauty', symbol: 'β', value: inputs.beta, min: 0.1, max: 5, step: 0.1, desc: 'Thermal buffer and multiplier.', onChange: function(v) { updateInput('beta', v); } }),
        h(SliderControl, { label: 'Toxicity', symbol: 'τ', value: inputs.tau, min: 0.5, max: 5, step: 0.1, desc: 'Penalty for unprocessed error.', onChange: function(v) { updateInput('tau', v); } })
      ),
      h('div', { className: 'sim-controls-col' },
        h('h4', { className: 'sim-section-title' }, 'Constants'),
        h(SliderControl, { label: 'Earn Rate', symbol: 'α', value: inputs.alpha, min: 0.01, max: 0.1, step: 0.01, desc: 'Trust gained per unit of metabolized error.', onChange: function(v) { updateInput('alpha', v); } }),
        h(SliderControl, { label: 'Burn Rate', symbol: 'γ', value: inputs.gamma, min: 0.01, max: 0.5, step: 0.01, desc: 'Trust destroyed per unit of toxic overflow.', onChange: function(v) { updateInput('gamma', v); } }),
        h(SliderControl, { label: 'Oligarchic Drift', symbol: 'δ', value: inputs.delta, min: 0.01, max: 0.2, step: 0.01, desc: 'Rate of stewardship decay per cycle.', onChange: function(v) { updateInput('delta', v); } }),
        h(SliderControl, { label: 'Hollow Penalty', symbol: 'κ', value: inputs.kappa, min: 0.1, max: 2.0, step: 0.1, desc: 'Damage from ritual exceeding trust.', onChange: function(v) { updateInput('kappa', v); } }),
        h(SliderControl, { label: 'Aesthetic Multi', symbol: 'λ', value: inputs.lambda, min: 0.05, max: 1.0, step: 0.05, desc: 'Efficiency gain from high beauty.', onChange: function(v) { updateInput('lambda', v); } }),
        h('div', { className: 'sim-reroll' },
          h('button', { onClick: function() { setSeed(Date.now()); }, className: 'sim-reroll-btn' },
            h(RefreshIcon),
            ' New Random Seed'
          )
        )
      )
    ),
    // Info box
    h('div', { className: 'sim-info' },
      h('div', { className: 'sim-info-content' },
        h(InfoIcon),
        h('div', null,
          h('p', null,
            h('strong', null, 'How to read this model:'),
            ' The black line is ',
            h('em', null, 'Explanatory Reach (S)'),
            '. The red dashed line is the ',
            h('em', null, 'Competitive Threshold (S̄)'),
            '—fall below it and you\'re outpaced. The gold dashed line is ',
            h('em', null, 'Ren / Trust (R)'),
            '. The faint gray line tracks ',
            h('em', null, 'Stewardship (C)'),
            '.'
          ),
          h('p', null,
            h('strong', null, 'Two failure modes:'),
            ' (1) ',
            h('em', null, 'Internal Collapse'),
            '—trust burns to zero. (2) ',
            h('em', null, 'Competitive Collapse'),
            '—S falls below S̄. Environmental melt (μᵉⁿᵛ) raises S̄ every cycle. You can\'t ignore it; you must metabolize it or be outcompeted.'
          )
        )
      )
    )
  );
}

const root = createRoot(document.getElementById('epimetabolic-simulation-root'));
root.render(h(EpimetabolicSimulation));
</script>
</body>
</html>
